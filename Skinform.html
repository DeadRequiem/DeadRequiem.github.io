<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Well of Souls Skinform Generator</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      margin-top: 10px;
      border: 1px solid #444;
      image-rendering: pixelated;
    }
    label {
      margin: 0 1em;
    }
  </style>
</head>
<body>
  <h1>Well of Souls Skinform Generator</h1>

  <label for="cellSize">Cell Size:</label>
  <select id="cellSize">
    <option value="48">48</option>
    <option value="72">72</option>
    <option value="96" selected>96</option>
    <option value="120">120</option>
    <option value="144">144</option>
    <option value="192">192</option>
    <option value="216">216</option>
    <option value="240">240</option>
    <option value="270">270</option>
    <option value="288">288</option>
  </select>

  <label>
    <input type="checkbox" id="includeMagic"> Include MAGIC cell
  </label>

  <button onclick="generateSkinform()">Generate</button>
  <button onclick="downloadBMP()">Download BMP</button>

  <br>
  <canvas id="preview" width="0" height="0"></canvas>

  <script>
    let gamePalette = null;
    let paletteLoaded = false;

    // Load the game palette on page load
    async function loadGamePalette() {
      try {
        const response = await fetch('souls.pal');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const arrayBuffer = await response.arrayBuffer();
        const paletteData = new Uint8Array(arrayBuffer);
        
        // Parse palette - assuming 256 colors, 3 bytes each (RGB)
        gamePalette = [];
        for (let i = 0; i < 256; i++) {
          const offset = i * 3;
          if (offset + 2 < paletteData.length) {
            gamePalette.push({
              r: paletteData[offset],
              g: paletteData[offset + 1],
              b: paletteData[offset + 2]
            });
          }
        }
        paletteLoaded = true;
        console.log(`Loaded palette with ${gamePalette.length} colors`);
      } catch (error) {
        console.error('Failed to load game palette:', error);
        // Fallback to basic palette
        gamePalette = [
          {r: 0, g: 128, b: 128},   // aqua
          {r: 0, g: 0, b: 0}        // black
        ];
        paletteLoaded = true;
      }
    }

    // Find closest palette color
    function findClosestPaletteIndex(r, g, b) {
      if (!gamePalette || gamePalette.length === 0) return 0;
      
      let closestIndex = 0;
      let closestDistance = Infinity;
      
      for (let i = 0; i < gamePalette.length; i++) {
        const color = gamePalette[i];
        const distance = Math.sqrt(
          Math.pow(r - color.r, 2) + 
          Math.pow(g - color.g, 2) + 
          Math.pow(b - color.b, 2)
        );
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = i;
        }
      }
      
      return closestIndex;
    }

    // Initialize palette loading
    window.addEventListener('load', loadGamePalette);

    function generateSkinform() {
      const size = parseInt(document.getElementById('cellSize').value);
      const includeMagic = document.getElementById('includeMagic').checked;
      const cells = includeMagic ? 7 : 6;
      const width = size * cells;
      const height = size;

      const canvas = document.getElementById('preview');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Aqua background
      ctx.fillStyle = 'rgb(0,128,128)';
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;

      // === Vertical cell borders ===
      // Add leftmost edge line at x = 0.5
      ctx.beginPath();
      ctx.moveTo(0.5, 0);
      ctx.lineTo(0.5, height);
      ctx.stroke();

      for (let i = 1; i < cells; i++) {
        const x = i * size + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }

      // Top & bottom border
      ctx.beginPath();
      ctx.moveTo(0, 0.5);
      ctx.lineTo(width, 0.5);
      ctx.moveTo(0, height - 0.5);
      ctx.lineTo(width, height - 0.5);
      ctx.stroke();

      // === MAP cell grid ===
      const third = size / 3;

      for (let i = 1; i < 3; i++) {
        const x = i * third + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, size);
        ctx.stroke();
      }

      for (let i = 1; i < 3; i++) {
        const y = i * third + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(size, y);
        ctx.stroke();
      }

      // === Shadow guide for all other cells ===
      const shadowY = size - (size / 6) + 0.5;
      for (let i = 1; i < cells; i++) {
        const x = i * size;
        ctx.beginPath();
        ctx.moveTo(x, shadowY);
        ctx.lineTo(x + size, shadowY);
        ctx.stroke();
      }

      // === Force top-left pixel to be pure aqua
      const imageData = ctx.getImageData(0, 0, 1, 1);
      imageData.data[0] = 0;   // R
      imageData.data[1] = 128; // G
      imageData.data[2] = 128; // B
      imageData.data[3] = 255; // A
      ctx.putImageData(imageData, 0, 0);
    }

    function downloadBMP() {
      const canvas = document.getElementById('preview');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      if (width === 0 || height === 0) {
        alert("Please generate a skinform first!");
        return;
      }
      
      const imageData = ctx.getImageData(0, 0, width, height).data;

      // === Convert to 8-bit palette indices ===
      const pixels = new Uint8Array(width * height);
      for (let i = 0; i < width * height; i++) {
        const r = imageData[i * 4];
        const g = imageData[i * 4 + 1];
        const b = imageData[i * 4 + 2];

        // Hardcoded palette: index 0 = aqua, 1 = black
        if (r === 0 && g === 0 && b === 0) {
          pixels[i] = 1; // black
        } else {
          pixels[i] = 0; // everything else becomes aqua
        }
      }

      // === RLE8 compression ===
      function rleEncode(data, width, height) {
        const output = [];
        for (let y = 0; y < height; y++) {
          let row = data.slice(y * width, (y + 1) * width);
          let i = 0;
          while (i < width) {
            const value = row[i];
            let runLength = 1;
            while (i + runLength < width && row[i + runLength] === value && runLength < 255) {
              runLength++;
            }

            if (runLength > 1) {
              output.push(runLength, value);
              i += runLength;
            } else {
              // Absolute mode
              let absStart = i;
              let absCount = 1;
              while (
                absStart + absCount < width &&
                (absCount < 255) &&
                (absCount < 3 || row[absStart + absCount] !== row[absStart + absCount - 1])
              ) {
                absCount++;
              }
              output.push(0, absCount);
              for (let j = 0; j < absCount; j++) {
                output.push(row[absStart + j]);
              }
              if (absCount % 2 === 1) output.push(0); // pad byte
              i += absCount;
            }
          }
          output.push(0, 0); // End of line
        }
        output.push(0, 1); // End of bitmap
        return new Uint8Array(output);
      }

      const rleData = rleEncode(pixels, width, height);

      // === BMP Header ===
      const fileHeaderSize = 14;
      const infoHeaderSize = 40;
      const paletteSize = 256 * 4;
      const pixelOffset = fileHeaderSize + infoHeaderSize + paletteSize;
      const fileSize = pixelOffset + rleData.length;

      const buffer = new ArrayBuffer(fileSize);
      const view = new DataView(buffer);

      let offset = 0;

      // BITMAPFILEHEADER
      view.setUint8(offset++, 0x42); // B
      view.setUint8(offset++, 0x4D); // M
      view.setUint32(offset, fileSize, true); offset += 4;
      view.setUint16(offset, 0, true); offset += 2; // reserved
      view.setUint16(offset, 0, true); offset += 2; // reserved
      view.setUint32(offset, pixelOffset, true); offset += 4;

      // BITMAPINFOHEADER
      view.setUint32(offset, infoHeaderSize, true); offset += 4;
      view.setInt32(offset, width, true); offset += 4;
      view.setInt32(offset, height, true); offset += 4;
      view.setUint16(offset, 1, true); offset += 2; // planes
      view.setUint16(offset, 8, true); offset += 2; // bits per pixel
      view.setUint32(offset, 1, true); offset += 4; // RLE8 compression
      view.setUint32(offset, rleData.length, true); offset += 4; // size image
      view.setInt32(offset, 2835, true); offset += 4; // X PPM
      view.setInt32(offset, 2835, true); offset += 4; // Y PPM
      view.setUint32(offset, 256, true); offset += 4; // used colors
      view.setUint32(offset, 0, true); offset += 4; // important colors

      // === Palette: index 0 = aqua, index 1 = black, rest = black
      const palette = new Uint8Array(256 * 4);
      palette[0] = 128;  // blue
      palette[1] = 128;  // green
      palette[2] = 0;    // red
      palette[3] = 0;

      palette[4] = 0;    // blue
      palette[5] = 0;    // green
      palette[6] = 0;    // red
      palette[7] = 0;

      new Uint8Array(buffer, fileHeaderSize + infoHeaderSize).set(palette);
      new Uint8Array(buffer, pixelOffset).set(rleData);

      const blob = new Blob([buffer], { type: 'image/bmp' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'skinform.bmp';
      a.click();
    }
  </script>
</body>
</html>